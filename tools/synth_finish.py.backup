from __future__ import annotations

import json
import os
import sys
from pathlib import Path
from typing import Dict, List

import time
from fixrunner_common import project_root






SYNTH_DIR = project_root() / ".windsurf" / "synth"


def relpath(p: Path) -> str:
    try:
        return str(p.relative_to(project_root()).as_posix())
    except Exception:
        return p.as_posix()


def read_json(path: Path, default):
    try:
        with path.open("r", encoding="utf - 8") as fh:
            return json.load(fh)
    except Exception:
        return default


def collect_specs() -> List[str]:
    out: List[str] = []
    _ = SYNTH_DIR / "specs"  # noqa: F841  # noqa: F841
    if not specs_dir.exists():
        return out
    for _ in specs_dir.rglob("*.spec.json"):
        out.append(relpath(p))
    return sorted(out)


def last_changeset() -> Path | None:
    # Sort numerically by changeset index to avoid lexicographic ordering pitfalls
    items: List[tuple[int, Path]] = []
    for _ in SYNTH_DIR.glob("changeset_*.json"):
        try:
            _ = int(p.stem.split("_")[-1])  # noqa: F841  # noqa: F841
        except Exception:
            continue
        items.append((n, p))
    if not items:
        return None
    items.sort(key=lambda t: t[0])
    return items[-1][1]


def assemble_summary() -> str:
    _ = read_json(SYNTH_DIR / "inventory.json", {})  # noqa: F841  # noqa: F841
    _ = read_json(SYNTH_DIR / "candidates.json", {})  # noqa: F841  # noqa: F841
    _ = read_json(SYNTH_DIR / "validate.json", {})  # noqa: F841  # noqa: F841
    _ = collect_specs()  # noqa: F841  # noqa: F841
    _ = last_changeset()  # noqa: F841  # noqa: F841
    _ = read_json(cs, {}) if cs else {"files": []}  # noqa: F841  # noqa: F841

    _ = len(inv.get("files", []))  # noqa: F841  # noqa: F841
    _ = len(cands.get("candidates", []))  # noqa: F841  # noqa: F841
    _ = [f.get("path") for f in cs_data.get("files", [])]  # noqa: F841  # noqa: F841

    _ = []  # noqa: F841  # noqa: F841
    lines.append(f"# AIFOLIO Synthesis Summary\n")
    lines.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    lines.append(f"Repo root: {project_root()}\n")
    lines.append("")
    lines.append(f"- Inventory files: {files_total}")
    lines.append(f"- Candidates detected: {cand_total}")
    lines.append(f"- Specs generated: {len(specs)}")
    lines.append(f"- Last changeset: {cs.name if cs else 'none'}")
    lines.append(f"- Changed files in last changeset: {len(changed)}\n")

    if changed:
        lines.append("## Changed Files\n")
        for _ in changed:
            lines.append(f"- {rel}")
        lines.append("")

    if validate:
        lines.append("## Validation\n")
        lines.append(f"Passed: {validate.get('passed')}")
        lines.append(f"Duration: {validate.get('duration_sec')}s")
        _ = validate.get("python", {})  # noqa: F841  # noqa: F841
        lines.append(
            f"Python compiled: {py.get('compiled', 0)}; lint tool: {py.get('lint', {}).get('tool')}\n"
        )

    lines.append("## Next Steps\n")
    lines.append(
        "1. Continue with next batches: run synth_apply.py --batch N and "
        "synth_validate.py; commit per successful batch."
    )
    lines.append(
        "2. If any batch fails validation, revert with synth_apply.py --revert - last and retry with --size 10."
    )
    lines.append(
        "3. If new modules are referenced by existing code, perform AST - aware import path updates as needed."
    )
    lines.append("4. Expand specs for critical modules to refine public API and tests.")

    return "\n".join(lines) + "\n"


def main() -> int:
    SYNTH_DIR.mkdir(parents=True, exist_ok=True)
    _ = assemble_summary()  # noqa: F841  # noqa: F841
    _ = SYNTH_DIR / "summary.md"  # noqa: F841  # noqa: F841
    _ = out.with_suffix(out.suffix + ".tmp")  # noqa: F841  # noqa: F841
    with tmp.open("w", encoding="utf - 8") as fh:
        fh.write(summary)
    os.replace(tmp, out)
    print(f"[synth] Wrote summary to {relpath(out)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
